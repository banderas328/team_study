<?php

$f = fopen("http://127.0.0.1/php7/team_study/Chapter15/large.txt", "rb") or die("Ошибка!");
echo $f;
echo "<br>";

//Различие текстового и бинарного режимов.
// Получает в параметрах строку и возвращает через пробел коды
// символов, из которых она состоит.
function makeHex($st)
{
for ($i = 0; $i < strlen($st); $i++)
    $hex[] = sprintf("%02X", ord($st[$i]));
return join(" ", $hex);
}

// Открываем файл скрипта разными способами
$f = fopen(__FILE__, "rb");  // бинарный режим
echo makeHex(fgets($f, 100)), "<br />\n";

$f = fopen(__FILE__, "rt"); // текстовый режим
echo makeHex(fgets($f, 100)), "<br />\n";

//Безымянный временный файл
//tmpfile();

//Чтение CSV-файла.
$f = fopen("large.txt", "rt") or die("Ошибка!");
for ($i = 0; $data = fgetcsv($f, 1000, ";"); $i++) {
    $num = count($data);
    echo "<h3>Строка номер $i (полей: $num):</h3>";
    for ($c = 0; $c < $num; $c++)
        print "[$c]: $data[$c]<br />";
}
fclose($f);

echo "<br>";

//Пример чтения файла
$f = fopen('large.txt', 'r');
while (!feof($f)) {
    echo $st = fgetc($f);
}
fclose($f);

echo "<br>";

//имя текущего файла
echo basename(__FILE__);//file_dir.php
echo "<br>";
//создание файла с уникальным именем
//echo tempnam(__DIR__, 'vgj');
echo "<br>";
echo getmygid();

//Прочитать файл целиком
print_r(file('large.txt'));
echo "<br>";
echo file_get_contents('large.txt');

//Чтение INI-файла.
$ini = parse_ini_file("file.ini", true);
echo "<pre>"; print_r($ini); echo "</pre>";
echo "Chip: {$ini['File Settings']['Chip']}";

/**
 * ***** Типы блокировок  ******

 Исключительная
 Разделяемая
 */
//Модель процесса-писателя.
$file = "large.txt";

// Вначале создаем пустой файл, ЕСЛИ ЕГО ЕЩЕ НЕТ.
// Если же файл существует, это его не разрушит.
fclose(fopen($file, "a+b"));

// Блокируем файл.
$f = fopen($file, "r+b") or die("Не могу открыть файл!");
flock($f, LOCK_EX); // ждем, пока мы не станем единственными

// . . .
// В этой точке мы можем быть уверены, что только эта
// программа работает с файлом.
// . . .

// Все сделано. Снимаем блокировку.
fclose($f);



//Модель процесса-читателя.
$file = "large.txt";

// Вначале создаем пустой файл, ЕСЛИ ЕГО ЕЩЕ НЕТ.
// Если же файл существует, это его не разрушит.
fclose(fopen($file, "a+b"));

// Блокируем файл.
$f = fopen($file, "r+b") or die("Не могу открыть файл!");
flock($f, LOCK_SH); // ждем, пока не завершится писатель

// . . .
// В этой точке мы можем быть уверены, что в файл
// никто не пишет.
// . . .

// Все сделано. Снимаем блокировку.
fclose($f);

/**
 * ***********  Вывод дерева каталогов файловой системы.  ************
 */
// Функция выводит имена всех подкаталогов в текущем каталоге,
// выполняя рекурсивный обход. Параметр $level задает текущую
// глубину рекурсии.
function printTree($level = 1) {
    // Открываем каталог и выходим в случае ошибки.
    $d = @opendir(".");
    if (!$d) return;
    while (($e = readdir($d)) !== false) {
        // Игнорируем элементы .. и .
        if ($e == '.' || $e == '..') continue;
        // Нам нужны только подкаталоги.
        if (!@is_dir($e)) continue;
        // Печатаем пробелы, чтобы сместить вывод.
        for ($i = 0; $i < $level; $i++) echo "  ";
        // Выводим текущий элемент.
        echo "$e\n";
        // Входим в текущий подкаталог и печатаем его
        if (!chdir($e)) continue;
        printTree($level + 1);
        // Возвращаемся назад
        chdir("..");
        // Отправляем данные в браузер, чтобы избежать видимости зависания
        // для больших распечаток.
        flush();
    }
    closedir($d);
}

// Выводим остальной текст фиксированным шрифтом
echo "<pre>";
echo "/\n";
// Входим в корневой каталог и печатаем его
chdir($_SERVER['DOCUMENT_ROOT']);
PrintTree();
echo "</pre>";